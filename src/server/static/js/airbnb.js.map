{"version":3,"file":"airbnb.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,2BAA2B,wBAAwB;AACnD;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,qDAAqD,kDAAkD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3xBA,YAAY,SAAS;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;UC/CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNwC;AACL;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,gDAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://airbnb/./src/ts/tstable/table.ts","webpack://airbnb/./src/ts/utils.ts","webpack://airbnb/webpack/bootstrap","webpack://airbnb/webpack/runtime/define property getters","webpack://airbnb/webpack/runtime/hasOwnProperty shorthand","webpack://airbnb/webpack/runtime/make namespace object","webpack://airbnb/./src/ts/airbnb.ts"],"sourcesContent":["// TODO: load css file thats shipped with lib, or make that nicer to set up\r\n// console.log(\"document.styleSheets\")\r\n// console.log(document.styleSheets)\r\n// var style = document.createElement('style');\r\n// style.type = 'text/css';\r\n// style.innerHTML = '.hidden { display: none; }';\r\n// document.getElementsByTagName('head')[0].appendChild(style);\r\n// document.getElementById('someElementId').className = 'cssClass';\r\n/**\r\n * basic table style\r\n * can be modified and passed to table\r\n *\r\n * INFO: not implemented!!\r\n * its just easier to use a css file with different classes\r\n * TODO: might be nice in some cases to setup without css, and easy to modify specific style params programmatically without setting classes\r\n */\r\nexport var tableStyle = {\r\n    custom: {\r\n        evenRows: '#f2f2f2'\r\n    },\r\n    table: {\r\n        fontFamily: 'Arial, Helvetica, sans-serif',\r\n        borderCollapse: 'collapse',\r\n        width: '100%'\r\n    },\r\n    th: {\r\n        border: '1px solid #ddd',\r\n        padding: '8px',\r\n        whiteSpace: 'nowrap',\r\n        // backgroundColor: 'green'\r\n    }\r\n};\r\n// Typeguards:\r\nfunction isArray(test) {\r\n    return Array.isArray(test);\r\n}\r\nfunction isTableRow(test) {\r\n    return test.rowIndex;\r\n}\r\nfunction isHTMLTableElement(test) {\r\n    return test === null || test === void 0 ? void 0 : test.tagName;\r\n}\r\n// ASK: can i configure private interfaces for the class\r\n// that reference tableData without the need to always n everywherer pass the generic type\r\n// var asdf : typeof Table= Table()\r\n// export class Table<Data extends TableData>{\r\nexport class Table {\r\n    //  get tableData() {\r\n    //     return this._tableData\r\n    // }\r\n    // public set tableData(tableData) {\r\n    //     console.log(\"setter table data\")\r\n    //     this._tableData = tableData;\r\n    //     // this.updateTableValues()\r\n    // }\r\n    /**\r\n     *\r\n     * @param tableHtml\r\n     * @param header Key = name of associated data field, value = display name\r\n     * @param tableData\r\n     * @param options\r\n     */\r\n    constructor(tableHtmlOrString, header, tableData, options = {}) {\r\n        this.tableHtml = this.getOrCreateTableHtml(tableHtmlOrString);\r\n        this.header = header;\r\n        // this._tableData = tableData\r\n        this.tableData = tableData;\r\n        this.options = options;\r\n        this.tableStyle = (options === null || options === void 0 ? void 0 : options.tableStyle) || tableStyle;\r\n        this.initialized = false;\r\n        // this.drawTable()\r\n    }\r\n    // call this when draw is called. so the properties can be set after initializing the table which makes type checkiing nicer\r\n    secondConstructor() {\r\n        // check once here or every time where now if(!this.filterConfig)\r\n        // would only make sense if the filter can be removed and the table does not re-draw\r\n        this.filterConfig = (typeof (this.options.filter) == \"object\" && this.options.filter.filterConfig) ? this.options.filter.filterConfig : null;\r\n    }\r\n    // TODO: getter, settter for tableData to update values in dom\r\n    getOrCreateTableHtml(tableHtmlOrString) {\r\n        var tableHtml;\r\n        if (isHTMLTableElement(tableHtmlOrString)) {\r\n            tableHtml = tableHtmlOrString;\r\n        }\r\n        else if (typeof tableHtmlOrString === \"undefined\") {\r\n            // table is created but needs to be manually added to dom\r\n            // id also has to be set on implementation side if needed\r\n            tableHtml = document.createElement(\"table\");\r\n        }\r\n        else if (typeof tableHtmlOrString === \"string\") {\r\n            let tableIdString = tableHtmlOrString;\r\n            var htmlById = document.getElementById(tableHtmlOrString);\r\n            var tagName = htmlById === null || htmlById === void 0 ? void 0 : htmlById.tagName;\r\n            if (tagName === \"TABLE\") {\r\n                tableHtml = htmlById;\r\n            }\r\n            else {\r\n                tableHtml = document.createElement(\"table\");\r\n                tableHtml.setAttribute(\"id\", tableIdString);\r\n                if (tagName === \"DIV\") {\r\n                    htmlById === null || htmlById === void 0 ? void 0 : htmlById.appendChild(tableHtml);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new ReferenceError(\"Table cant be initialized with provided html Element.\");\r\n        }\r\n        return tableHtml;\r\n    }\r\n    getDataByIndex(row, col) {\r\n        // TODO implement for dict\r\n        // todo change data type with infer and refactor these array checks\r\n        if (Array.isArray(this.tableData)) {\r\n            return this.tableData[row - 1][Object.keys(this.header)[col]];\r\n        }\r\n    }\r\n    // TODO: args any just keys of data, return type also whatever is possible on specific data\r\n    // setDataByIndex(rowIndexData: number, colKeyOrIndex: number | string, data: number | string | ((...args: any) => number | string)) {\r\n    setDataByIndex(rowIndexData, colKeyOrIndex, data) {\r\n        // TODO implement for dict\r\n        if (Array.isArray(this.tableData)) {\r\n            // let colIndex = (typeof col === \"string\") ? col : Object.keys(this.header)[col]\r\n            let colIndexNr;\r\n            let colIndexStr;\r\n            let headerKeys = Object.keys(this.header);\r\n            if (typeof colKeyOrIndex === \"string\") {\r\n                // col as string (in header or maybe new value for calculation)\r\n                colIndexNr = headerKeys.indexOf(colKeyOrIndex); // index in header or -1 if not in header / dom\r\n                colIndexStr = colKeyOrIndex;\r\n            }\r\n            else {\r\n                // col as number (in header)\r\n                colIndexNr = colKeyOrIndex;\r\n                colIndexStr = headerKeys[colKeyOrIndex];\r\n            }\r\n            this.tableData[rowIndexData][colIndexStr] = data;\r\n            if (colIndexNr != -1) {\r\n                if (this.initialized)\r\n                    this.updateTableValues(rowIndexData, colIndexNr, colIndexStr);\r\n            }\r\n            // TODO: idk yet how to solve. atm dont update after set but do it manually bc of tax calculation that happens afterwards\r\n            // this.updateTableValues()\r\n        }\r\n    }\r\n    /**\r\n     * only called from setDataByIndex\r\n     *      data can be set onEdit or manually by user at any time\r\n     * setDataByIndex - sets the data then calls -> updateTableValues - updates the html table cell\r\n     *\r\n     * @param row\r\n     * @param colNr\r\n     * @param colStr\r\n     * @returns\r\n     */\r\n    // TODO: private?\r\n    updateTableValues(rowIndexData, colIndex, colStr) {\r\n        // TODO: atm if table already rendered, render the row\r\n        if (this.initialized) {\r\n            colIndex = undefined;\r\n            colStr = undefined;\r\n        }\r\n        // check data structure\r\n        if (Array.isArray(this.tableData)) { //TODO!!! check dependency fields\r\n            let rows = this.tableHtml.rows;\r\n            // if row, col param updat only what is necessary\r\n            if (rowIndexData != undefined && colIndex != undefined && colStr != undefined) {\r\n                console.log(\"update table value\");\r\n                // index in table is shifted by 1 bc of header\r\n                let rowIndexTable = rowIndexData + 1;\r\n                let cell = rows[rowIndexTable].cells[colIndex];\r\n                cell.innerHTML = String(this.tableData[rowIndexData][colStr]);\r\n                return;\r\n            }\r\n            // data starting with index 0, table starting with index 1 because 0 is the header\r\n            let rowIndex = rowIndexData != undefined ? rowIndexData + 1 : 1;\r\n            let rowIndexEnd = rowIndexData != undefined ? rowIndexData + 2 : rows.length;\r\n            // update all cells / one specific row\r\n            console.log(rowIndexData === undefined ? \"update ALLL table values\" : \"update table Row \" + rowIndex);\r\n            // starting with index 1; 0 is the header\r\n            for (rowIndex; rowIndex < rowIndexEnd; rowIndex++) {\r\n                const row = rows[rowIndex];\r\n                let cells = row.cells;\r\n                for (let colIndex = 0; colIndex < cells.length; colIndex++) {\r\n                    const cell = cells[colIndex];\r\n                    // cell.classList.add(\"bluee\")\r\n                    // todo need that?\r\n                    let headerKeys = Object.keys(this.header);\r\n                    let key = headerKeys[colIndex];\r\n                    // console.log(this.tableData[dataRowIndex][key])\r\n                    // console.log('innerhtml')\r\n                    // console.log(this.tableData[rowIndex][key])\r\n                    // data starting with index 0, table starting with index 1 because 0 is the header\r\n                    cell.innerHTML = String(this.tableData[rowIndex - 1][key]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO: implement this feature to update dependent cells on edit etc, visualize affected fields\r\n    // colExp: (...args: any) => number = (args) => {\r\n    //     var d = tableData[keyOrIndex]\r\n    //     console.log(args)\r\n    //     let cost = d[args.vol] * d[args.price]\r\n    //     // when table is already rendered update the cells\r\n    //     if(tableTrades.initialized){\r\n    //       tableTrades.\r\n    //     }\r\n    //     return cost\r\n    //   }\r\n    // update cell value\r\n    // TODO: maybe more params could be needed outside in the callback, eg. pass table\r\n    onEdit(event, keyOrIndex) {\r\n        let cell = event.currentTarget;\r\n        let row = cell.parentElement;\r\n        let cellIndex = cell.cellIndex;\r\n        // when getting index from table, -1 because of header\r\n        let rowIndexData = row.rowIndex - 1;\r\n        var valNew = cell.innerHTML;\r\n        //TODO: atm onclick set the data for the clicked, then transform data, from there set all fields of the row\r\n        this.tableHtml.tHead = null;\r\n        this.drawTable();\r\n        return;\r\n        this.setDataByIndex(rowIndexData, cellIndex, valNew);\r\n        this.transformData(row, rowIndexData);\r\n        // ASK: pass row, cell as index html or string??\r\n        if (this.options.editable && typeof this.options.editable === \"function\")\r\n            this.options.editable(row, cell, this.tableData);\r\n        // if (this.options.transformData) {\r\n        //     this.options.transformData(row, keyOrIndex as KeyOrIndex<Data>, this.tableData, this)\r\n        // }\r\n    }\r\n    addRowOnTop(data) {\r\n    }\r\n    transformData(row, keyOrIndex) {\r\n        if (this.options.transformData) {\r\n            this.options.transformData(row, keyOrIndex, this.tableData, this);\r\n        }\r\n    }\r\n    drawTable() {\r\n        var _a;\r\n        // console.debug(\"draw Table \" + this.tableHtml.id != '' ? this.tableHtml.id : \"no id - consider setting an ID before table.drawTable()\");\r\n        console.debug(\"draw Table \" + (this.tableHtml.id != '' ? this.tableHtml.id : \"with no id - consider setting an ID before table.drawTable()\") + \" with \" + this.tableData.length + \" rows\");\r\n        // call these things here so i can set them after new Table and before drawing\r\n        // TODO: check if this makes sense\r\n        this.secondConstructor();\r\n        if (this.initialized)\r\n            console.warn(\"TODO: Possible error? drawTable should not be usded to update the table! \" +\r\n                \"Instead use the update methode/s which aim to keep the data object, tablecells and its dependent fields in sync\");\r\n        // HEADER\r\n        let thead = this.tableHtml.createTHead();\r\n        // insert searchbar in header if option is checked\r\n        let searchRow = thead.insertRow();\r\n        let searchCell = document.createElement(\"td\");\r\n        searchCell.setAttribute(\"colspan\", String(Object.keys(this.header).length));\r\n        searchRow.append(searchCell);\r\n        if (this.options.search) {\r\n            let searchInput = document.createElement(\"input\");\r\n            searchInput.type = \"text\";\r\n            searchInput.placeholder = \"Searcg for anything in Row or filter\";\r\n            searchInput.id = this.tableHtml.id + \"_search\";\r\n            searchInput.style.float = \"left\"; // todo better style wo float\r\n            let searchVal = \"\";\r\n            searchInput.onkeyup = (ev) => {\r\n                if (searchInput.value === searchVal)\r\n                    return;\r\n                let filter = {\r\n                    val: searchInput.value,\r\n                    include: searchInput.value < searchVal ? true : false // true -> deleted char -> include hidden rows(depending on other filters), false - added char --> narrow / remove visible rows\r\n                };\r\n                searchVal = searchInput.value;\r\n                this.filter_oneAtATime(filter);\r\n            };\r\n            searchCell.append(searchInput);\r\n        }\r\n        if (this.options.rowCount != false) {\r\n            let rowCnterHtml = document.createElement(\"div\");\r\n            rowCnterHtml.id = this.tableHtml.id + \"_row-counter\";\r\n            rowCnterHtml.innerHTML = String(this.tableData.length);\r\n            console.log(\"counter\");\r\n            console.log(rowCnterHtml);\r\n            searchCell.append(rowCnterHtml);\r\n        }\r\n        // insert filter box in header if option is checked\r\n        var filterRow = null;\r\n        if (this.options.filter) {\r\n            filterRow = thead.insertRow();\r\n        }\r\n        let rowHeader = thead.insertRow();\r\n        var colNr = 0;\r\n        for (let key in this.header) {\r\n            let nr = colNr;\r\n            let th = document.createElement(\"th\");\r\n            // Object.assign(th.style, tableStyle.th);\r\n            // th.style.cssText = \" border: 1px solid #ddd;\"\r\n            // if sortable\r\n            if ((_a = this.options.sortable) === null || _a === void 0 ? void 0 : _a.all) {\r\n                th.addEventListener('click', () => { this.sortTable(nr), this.changeColourEvenRows(); }, false);\r\n                // TODO: implement for specific cols only / possibility to disable some\r\n            }\r\n            let text = document.createTextNode(this.header[key]);\r\n            th.appendChild(text);\r\n            rowHeader.appendChild(th);\r\n            colNr++;\r\n        }\r\n        // TABLE\r\n        // check data structure\r\n        var dataIsArray = Array.isArray(this.tableData);\r\n        var keyOrIndex;\r\n        // var keyOrIndex: KeyOrIndex<Data>\r\n        // if(Array.isArray(this.tableData)) keyOrIndex = 7\r\n        let tbody = this.tableHtml.createTBody();\r\n        // TODO: check this here y did i not put it in the function??\r\n        // for in returns key (and also Array index) as string\r\n        for (keyOrIndex in this.tableData) {\r\n            // convert string to number for tsc - only necessary when checking for types when indexing data (arr/dict)\r\n            // tried a million years and approches but there is not satisfying way to make ts understand it, it seems\r\n            // TODO document in md\r\n            if (isArray(this.tableData))\r\n                keyOrIndex = +keyOrIndex; //!!!!\r\n            this.addRow(tbody, keyOrIndex);\r\n        }\r\n        // filter box for this table\r\n        if (filterRow) {\r\n            this.addFilterBox(filterRow);\r\n        }\r\n        // TODO: when is this used? while buildigng sdlfjs;fdl\r\n        this.initialized = true;\r\n        this.changeColourEvenRows();\r\n    }\r\n    addRow(tbody, keyOrIndex) {\r\n        let row = document.createElement(\"tr\");\r\n        // transform row data, called for each row TODO: that good here or call once and set all\r\n        if (this.options.transformData) {\r\n            this.transformData(row, keyOrIndex);\r\n            // this.options.transformData(row, keyOrIndex as KeyOrIndex<Data>, this.tableData, this)\r\n        }\r\n        // generate columns\r\n        for (const col in this.header) {\r\n            let value;\r\n            // @ts-ignore\r\n            // for-in and Object.Keys return elements as string, \r\n            // if Array its certenly a number; if Dict its definitely a string\r\n            // nice and easy js solution:\r\n            // \r\n            // keyTableData is a special col that is associated with the key of the object that contains the rest of the cols as values\r\n            value = col == 'keyTableData' ? keyOrIndex : this.tableData[keyOrIndex][col];\r\n            var cell = document.createElement(\"td\");\r\n            // TODO: Test performance difference with concated string \r\n            // also create rows first then render in one go, createElement for cols instead of insertCell already makes a difference\r\n            // set same class for each cell in a col, TODO: remove bc possible collisions except I find a valid usecase \r\n            cell.classList.add(col);\r\n            // make editable\r\n            // TODO: move events outside in config\r\n            if (this.options.editable) {\r\n                cell.setAttribute(\"contenteditable\", \"true\");\r\n                cell.addEventListener('blur', (event) => {\r\n                    this.onEdit(event, keyOrIndex);\r\n                });\r\n                // more events but blur might be all thats needed\r\n                // cell.addEventListener('click', (el: any) => this.onEdit(el))\r\n                // cell.addEventListener('keyup', (el: any) => this.onEdit(el))\r\n                // cell.addEventListener('paste', (el: any) => this.onEdit(el))\r\n                // cell.addEventListener('input', (el: any) => this.onEdit(el))\r\n            }\r\n            let text = document.createTextNode(String(value));\r\n            cell.appendChild(text);\r\n            row.appendChild(cell);\r\n        }\r\n        // add row to table body\r\n        tbody.appendChild(row);\r\n        // this.tableHtml.tBodies[0].appendChild(row)\r\n        // function to manipulate row from outside, after it is rendered!\r\n        if (this.options.rowFunc) {\r\n            this.options.rowFunc(row, keyOrIndex, this.tableData, this);\r\n        }\r\n        // collapsible Row:\r\n        if (this.options.collapsible) {\r\n            let rowHidden = this.tableHtml.insertRow();\r\n            let cell = rowHidden.insertCell();\r\n            cell.colSpan = Object.keys(this.header).length;\r\n            cell.style.display = \"none\";\r\n            // call callback function to fill the hidden cell\r\n            this.options.collapsible(cell, keyOrIndex, this.tableData);\r\n            if (row) {\r\n                row.onclick = () => {\r\n                    // toggle visibility\r\n                    if (cell.style.display === \"none\") {\r\n                        cell.style.removeProperty('display');\r\n                    }\r\n                    else {\r\n                        cell.style.display = \"none\";\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n    addFilterBox(filterRow) {\r\n        console.log(\"add filter box for table \" + this.tableHtml.id);\r\n        let config;\r\n        if (this.filterConfig) {\r\n            config = this.filterConfig;\r\n        }\r\n        else if (this.options.filter == true) {\r\n            // TODO detect reoccuring values and provide filter\r\n        }\r\n        else {\r\n            console.error(\"this should not happen, filters should not be activiated for this table right?\");\r\n        }\r\n        console.log(\"filter config\");\r\n        console.log(config);\r\n        // insert filters in cols\r\n        for (let key in this.header) {\r\n            let filterCol = document.createElement(\"td\");\r\n            let type = config[key];\r\n            if (typeof type == \"object\") {\r\n                // string literal filter\r\n                // TODO low: add custom filter cb \r\n                // if (this.options.filter.custom) {}\r\n                // invert selection\r\n                let divInvert = document.createElement(\"div\");\r\n                divInvert.innerHTML = \"invert\";\r\n                filterCol.append(divInvert);\r\n                for (const val of Object.keys(type)) {\r\n                    let div = document.createElement(\"div\");\r\n                    div.innerHTML = val;\r\n                    div.classList.add(\"table-filter-literal\");\r\n                    div.addEventListener(\"click\", () => this.onSwitchfilter(div, val, key));\r\n                    filterCol.append(div);\r\n                }\r\n            }\r\n            else if (type === \"number\") {\r\n                // range filter\r\n                let inputBottom = document.createElement(\"input\");\r\n                let inputTop = document.createElement(\"input\");\r\n                inputBottom.placeholder = \"min val\";\r\n                inputTop.placeholder = \"max val\";\r\n                inputBottom.classList.add(\"table-filter-range\");\r\n                inputTop.classList.add(\"table-filter-range\");\r\n                filterCol.append(inputBottom, \" < x < \", inputTop);\r\n            }\r\n            else if (type === \"string\") {\r\n                // search filter\r\n                let searchInput = document.createElement(\"input\");\r\n                searchInput.placeholder = \"filter \" + key;\r\n                searchInput.classList.add(\"table-filter-search-col\");\r\n                filterCol.append(searchInput);\r\n            }\r\n            else {\r\n                // todo: handle undefined\r\n                // throw \"filter config has invalid values in col \" + key\r\n            }\r\n            // let text = document.createTextNode(type);\r\n            // filterCol.appendChild(text);\r\n            filterRow.appendChild(filterCol);\r\n        }\r\n    }\r\n    onSwitchfilter(divHtml, filterVal, colKey) {\r\n        // todo, idea maybe build data graph with filter values use it to import the possibilities instead of array and to store the state for custom tables\r\n        let include = !divHtml.classList.toggle(\"table-filter-val-exclude\");\r\n        if (this.filterConfig && colKey) {\r\n            // set filter state in filterconfig (filter enabled / disabled) \r\n            this.filterConfig[colKey][filterVal] = include;\r\n        }\r\n        console.log(\"swithced filter\");\r\n        console.log(this.filterConfig);\r\n        let filter = {\r\n            val: filterVal,\r\n            include: include\r\n        };\r\n        this.filter_oneAtATime(filter, colKey);\r\n    }\r\n    // onSearch(input: HTMLInputElement) {\r\n    //     let filter = input.value.toLowerCase();\r\n    //     let rowsT = this.tableHtml.tBodies[0].rows\r\n    //     var cells, txtValue;\r\n    //     console.time('test');\r\n    //     for (let i = 0; i < rowsT.length; i++) {\r\n    //         // console.log(rowsT[i])\r\n    //         var rowVisible = false\r\n    //         cells = rowsT[i].getElementsByTagName(\"td\");\r\n    //         for (let j = 0; j < cells.length; j++) {\r\n    //             let cell = cells[j]\r\n    //             if (cell) {\r\n    //                 txtValue = cell.textContent || cell.innerText;\r\n    //                 let cellVal = txtValue.toLowerCase().replace(\",\", \"\")\r\n    //                 if (cellVal.indexOf(filter) > -1) {\r\n    //                     rowVisible = true\r\n    //                     break;\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //         if (rowVisible == false) {\r\n    //             rowsT[i].style.display = \"none\";\r\n    //         }\r\n    //     }\r\n    //     console.timeEnd('test');\r\n    // }\r\n    // combined filter, applies every filter and search input \r\n    // filter_searchAndFilters(input: HTMLInputElement) {\r\n    filter_byConfig(filter, colKey) {\r\n    }\r\n    /**\r\n     * @description takes one change in filter config\r\n     * loop over all entries and hide / show\r\n     * @param filter\r\n     * @param filter.val value for comparison\r\n     * @param filter.include true = filter removed, false = filter applied //wether row with matching val should be included or removed\r\n     * @param colKey if not set -> all cols - equivalent to search\r\n     */\r\n    filter_oneAtATime(filter, colKey) {\r\n        // function is triggered when a filter changes and the change gets applied\r\n        // executed for EVERY change in filter config - one change at a time\r\n        // \r\n        // filter is ether:\r\n        //      - col specific\r\n        //      - all cols - search\r\n        // \r\n        // narrow or widening is considered here.\r\n        // only bother with rows not included if filter gets removed / widening\r\n        // \r\n        // DOM manipulation:\r\n        // All possible rows, stored in tableData, are created and depending on filtering\r\n        // with CSS display property hidden.\r\n        // \r\n        // Thoughts:\r\n        // TODO: ASK: integrate some type of interrupt, webworkers, timeout, etc for when filters r set fast and tables r big\r\n        // different cases and, exiting loops etc is pretty well considered i think, but sadly its compleately negligible in comparison to painting the dom.\r\n        // this is the real bottleneck \r\n        // had a lot of thoughts on paging n caching etc. but might just be enough to keep everything in mem to sort n filter but limit rendered results to eg 50 row page which renders fast af. \r\n        console.log(filter);\r\n        // triggered by search:\r\n        // no colKey - check EVERY col till val found --> then include the row\r\n        // include true - widen - check hidden rows for filter.val\r\n        // include false - narrow - check visible rows for filter.val\r\n        // if search input:\r\n        //      add search string as filter to visible rows\r\n        let search = document.getElementById(this.tableHtml.id + \"_search\");\r\n        let rowsT = this.tableHtml.tBodies[0].rows;\r\n        let rowsD = this.tableData;\r\n        console.time('test');\r\n        // check each row:\r\n        // todo change to data instead of dom and benchmark\r\n        for (let i = 0; i < rowsT.length; i++) {\r\n            if (Array.isArray(rowsD)) {\r\n                let rowD = rowsD[i];\r\n                // skip row if current filter does not match\r\n                if (colKey) {\r\n                    let val = rowD[colKey];\r\n                    if (val != (filter === null || filter === void 0 ? void 0 : filter.val))\r\n                        continue;\r\n                }\r\n                let rowT = rowsT[i];\r\n                // rows affected by filter modification:\r\n                // case 1: row is hidden and filter gets removed\r\n                //      check wether it should be made visible\r\n                // case 2: row is visible and filter gets applied\r\n                //      check if filter.incude is false -> hide\r\n                // case 1: row is hidden but filter says show it:\r\n                if ((rowT.style.display === \"none\" && filter.include === true)) {\r\n                    // console.log(\"removed filter\")\r\n                    if (!this.filterConfig)\r\n                        throw new Error(\"cant filter, No Filter Config\");\r\n                    // depending on other filters, re-enable row\r\n                    var rowVisible = true;\r\n                    // set true when search val is found in row or no search val\r\n                    var rowVisibleSearch = search.value ? false : true;\r\n                    //todo\r\n                    // check if any other filter is false --> hide\r\n                    //      if yes - continue dont bother search val\r\n                    //      if not - check all cols for search val\r\n                    for (let col in this.header) {\r\n                        // already checked before, but idk if this if helps at all todo\r\n                        // if(col === colKey) continue;\r\n                        // SEARCH\r\n                        // check cols for searchstring until found --> then know its not hidden --> unhide\r\n                        if (search.value && rowVisibleSearch === false) {\r\n                            console.log(\"filter search\");\r\n                            let searchVal = search.value.toLocaleLowerCase();\r\n                            let cellVal = String(rowD[col]);\r\n                            cellVal = cellVal.toLowerCase().replace(\",\", \"\");\r\n                            if (cellVal.indexOf(searchVal) > -1) {\r\n                                rowVisibleSearch = true;\r\n                                // break;\r\n                            }\r\n                        }\r\n                        // OTHER FILTERS\r\n                        // check if any filter hides row --> then break and keep hidden\r\n                        let filterConfCol = this.filterConfig[col];\r\n                        if (!filterConfCol)\r\n                            continue;\r\n                        let cellVal = rowD[col];\r\n                        // check for filter till filter matches --> then hide\r\n                        if (typeof filterConfCol == \"object\" && rowVisible) { // todo\r\n                            for (const literal in filterConfCol) {\r\n                                const include = filterConfCol[literal];\r\n                                // if exclude - compare with actual value in cell - if match remove row \r\n                                if (include)\r\n                                    continue;\r\n                                if (literal === cellVal) {\r\n                                    rowVisible = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            // if (!rowVisible) break;\r\n                        }\r\n                        else if (filterConfCol === \"number\") {\r\n                        }\r\n                        else if (filterConfCol === \"string\") {\r\n                        }\r\n                        else {\r\n                            console.log(rowVisible);\r\n                            // todo: handle undefined\r\n                            throw \"filter config has invalid values in col \" + col;\r\n                        }\r\n                        // if(!rowVisible || rowVisibleSearch) break;\r\n                        if (!rowVisible)\r\n                            break;\r\n                    }\r\n                    // re-enable row , todo move out of if\r\n                    if (rowVisible && rowVisibleSearch) {\r\n                        rowsT[i].style.display = \"\";\r\n                    }\r\n                    else {\r\n                        // todo shouldnt be here should be iin funct\r\n                        // rowsT[i].style.display = \"none\";\r\n                    }\r\n                }\r\n                else if (rowT.style.display == \"\" && filter.include === false) {\r\n                    // this row should be excluded and colKey matches value (checked at start of fumc)\r\n                    if (colKey) {\r\n                        rowT.style.display = \"none\";\r\n                        continue;\r\n                    }\r\n                    console.log(\"should be search only\");\r\n                    let rowVisibleSearch = false;\r\n                    // search text was appended\r\n                    for (let col in this.header) {\r\n                        // already checked before, but idk if this if helps at all todo\r\n                        // if(col === colKey) continue;\r\n                        // check cols for searchstring until found --> then know its not hidden --> unhide\r\n                        if (rowVisibleSearch === false) {\r\n                            console.log(\"filter search\");\r\n                            let searchVal = search.value.toLocaleLowerCase();\r\n                            let cellVal = String(rowD[col]);\r\n                            cellVal = cellVal.toLowerCase().replace(\",\", \"\");\r\n                            if (cellVal.indexOf(searchVal) > -1) {\r\n                                console.log(cellVal + \"cellval u searchval\" + searchVal);\r\n                                rowVisibleSearch = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (!rowVisibleSearch) {\r\n                        console.log(\"row true\");\r\n                        rowsT[i].style.display = \"none\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // visible row number:\r\n        // todo\r\n        // could work that into the above loop, but for some reason when testing it is even slower without this extra loop than with it?? wtf!! and if not it still doesnt matter bc slow af rendering taking 100x of script\r\n        // todo check with option to disable row cnt. i think it will not create the html n therefore not execute here \r\n        let rowCnterHtml = document.getElementById(this.tableHtml.id + \"_row-counter\");\r\n        if (rowCnterHtml) {\r\n            let cntRowsVisible = 0;\r\n            for (let i = 0; i < rowsT.length; i++) {\r\n                let rowT = rowsT[i];\r\n                if (rowT.style.display == \"\") {\r\n                    cntRowsVisible++;\r\n                }\r\n            }\r\n            rowCnterHtml.innerHTML = String(cntRowsVisible) + \" / \" + String(rowsT.length);\r\n        }\r\n        console.timeEnd('test');\r\n    }\r\n    filter(filterVal, colKey) {\r\n        console.log(\"colKey\");\r\n        console.log(filterVal);\r\n        // implemented for array, todo: implement all that shit for dict or just map it\r\n        if (Array.isArray(this.tableData)) {\r\n            // by col and bool selection\r\n            if (colKey && filterVal) {\r\n                // go thru data and filter\r\n                var rowNr = 0;\r\n                var hitNr = 0;\r\n                var rowsT = this.tableHtml.tBodies[0].rows; // rowT - html, rowD - data\r\n                console.log(\"rowsT.length\");\r\n                console.log(rowsT.length);\r\n                for (const rowD of this.tableData) {\r\n                    let val = rowD[colKey];\r\n                    let rowT = rowsT[rowNr];\r\n                    // console.log(row)\r\n                    if (val === filterVal) {\r\n                        console.log(rowT.style.display);\r\n                        if (rowT.style.display == \"none\") {\r\n                            rowT.style.display = \"\";\r\n                        }\r\n                        else {\r\n                            rowT.style.display = \"none\";\r\n                        }\r\n                        hitNr++;\r\n                    }\r\n                    rowNr++;\r\n                }\r\n            }\r\n            // todo: by string or num range, by col or whole thing\r\n        }\r\n    }\r\n    sortTable(n) {\r\n        var _a, _b;\r\n        console.log('sorting the table');\r\n        // Inserting more than one row is not rlly necessary.\r\n        const rowOffset = this.options.collapsible ? 2 : 1;\r\n        var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;\r\n        table = this.tableHtml;\r\n        switching = true;\r\n        //Set the sorting direction to ascending:\r\n        dir = \"asc\";\r\n        /*Make a loop that will continue until\r\n        no switching has been done:*/\r\n        while (switching) {\r\n            //start by saying: no switching is done:\r\n            switching = false;\r\n            // only rows in body, leave header rows out of it\r\n            rows = table.tBodies[0].rows;\r\n            /*Loop through all table rows (except the\r\n                first, which contains table headers):*/\r\n            for (i = 0; i < (rows.length - rowOffset); i = i + rowOffset) {\r\n                //start by saying there should be no switching:\r\n                shouldSwitch = false;\r\n                /*Get the two elements you want to compare,\r\n                one from current row and one from the next:*/\r\n                x = rows[i].getElementsByTagName(\"td\")[n];\r\n                // +2 because of the collapsible rows\r\n                y = rows[i + rowOffset].getElementsByTagName(\"td\")[n];\r\n                var cmpX = isNaN(parseFloat(x.innerHTML)) ? x.innerHTML.toLowerCase() : parseFloat(x.innerHTML);\r\n                var cmpY = isNaN(parseFloat(y.innerHTML)) ? y.innerHTML.toLowerCase() : parseFloat(y.innerHTML);\r\n                // NOTE: idk when this occours? with parseFloat or lowercase??\r\n                cmpX = (cmpX == '-') ? 0 : cmpX;\r\n                cmpY = (cmpY == '-') ? 0 : cmpY;\r\n                /*check if the two rows should switch place,\r\n                based on the direction, asc or desc:*/\r\n                if (dir == \"asc\") {\r\n                    if (cmpX > cmpY) {\r\n                        //if so, mark as a switch and break the loop:\r\n                        shouldSwitch = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (dir == \"desc\") {\r\n                    if (cmpX < cmpY) {\r\n                        //if so, mark as a switch and break the loop:\r\n                        shouldSwitch = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (shouldSwitch) {\r\n                /*If a switch has been marked, make the switch\r\n                and mark that a switch has been done:*/\r\n                (_a = rows[i].parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(rows[i + rowOffset], rows[i]);\r\n                if (rowOffset == 2) {\r\n                    // also move the hidden row\r\n                    (_b = rows[i].parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(rows[i + rowOffset + 1], rows[i + 1]);\r\n                }\r\n                switching = true;\r\n                //Each time a switch is done, increase this count by 1:\r\n                switchcount++;\r\n            }\r\n            else {\r\n                /*If no switching has been done AND the direction is \"asc\",\r\n                set the direction to \"desc\" and run the while loop again.*/\r\n                if (switchcount == 0 && dir == \"asc\") {\r\n                    dir = \"desc\";\r\n                    switching = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    changeColourEvenRows() {\r\n        if (this.options.alternateColour == false)\r\n            return;\r\n        var rows = this.tableHtml.rows;\r\n        var cnt = 0;\r\n        for (let i = 0; i < rows.length; i++) {\r\n            // only count visible rows\r\n            if (!(rows[i].cells[0].style.display == \"none\")) {\r\n                rows[i].style.removeProperty('background-color');\r\n                // set custom colour for every other row \r\n                if (cnt % 2 == 0)\r\n                    rows[i].style.backgroundColor = this.tableStyle.custom.evenRows;\r\n                cnt++;\r\n            }\r\n        }\r\n    }\r\n}\r\n","// import { config } from './config'\r\nconst config = { baseUrl: \"\" };\r\n/**\r\n * fetch with url and headers\r\n *\r\n * @param url\r\n * @param params optional\r\n * @returns Promise< <T> | Error>\r\n */\r\n// TODO: y is error not shown as return type when its thrown in the catch?\r\n// TODO, ASK: Dictionary<string> is needed for URLSearchParams but then i cant check for numbers in the calling functions\r\nexport function fetchEzy(url, params) {\r\n    // add base URL for internal API\r\n    // internal API EPs have to start with _underscore\r\n    var sUrl = url[0] === \"_\" || url[0] === \"/_\" ? config.baseUrl + url : url;\r\n    console.log(sUrl);\r\n    // Add params\r\n    var bParamsAlready = sUrl.indexOf(\"?\") !== -1 ? true : false;\r\n    if (params)\r\n        sUrl = bParamsAlready ?\r\n            sUrl + \"&\" + new URLSearchParams(params) :\r\n            sUrl + \"?\" + new URLSearchParams(params);\r\n    console.log(\"[fetchEzy] \" + sUrl);\r\n    // console.log(sUrlWithParams)\r\n    return fetch(sUrl)\r\n        .then(res => {\r\n        if (!res.ok)\r\n            throw new Error(res.status.toString());\r\n        const contentType = res.headers.get('content-type');\r\n        // console.log(contentType)\r\n        if (contentType && contentType.includes('application/json')) {\r\n            return res.json();\r\n        }\r\n        console.log(\"test in fetchEzy - her the respnse is not jsonified but turned to unknown n then promise with type\");\r\n        return res;\r\n    })\r\n        .then(res => {\r\n        var _a;\r\n        // check internal api error response\r\n        if ((_a = res.error) === null || _a === void 0 ? void 0 : _a.length)\r\n            throw new Error(JSON.stringify(res.error));\r\n        return res;\r\n    })\r\n        .catch(err => {\r\n        // return Promise.reject(\"could not fetch \" + sUrl + \": \" + err);\r\n        throw new Error(\"could not fetch \" + sUrl + \": \" + err.stack);\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Table } from \"./tstable/table\";\r\nimport { fetchEzy } from \"./utils\";\r\nconsole.log(\"airbnb\");\r\nwindow.addEventListener('DOMContentLoaded', function () {\r\n    let updateBtn = document.getElementById(\"update\");\r\n    if (updateBtn) {\r\n        updateBtn.addEventListener(\"click\", () => {\r\n            console.log(\"btn\");\r\n            fetchEzy('/scrape').then(res => {\r\n                console.log(\"data updated!!!\");\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        alert(\"err\");\r\n    }\r\n});\r\ngetTable();\r\nexport function getTable() {\r\n    getData().then(data => {\r\n        // process data in place\r\n        constructTable(data);\r\n    });\r\n}\r\n;\r\nfunction getData() {\r\n    return fetchEzy('/rooms/all').then(res => {\r\n        // return fetchEzy<TableData>('/scrape').then(res => {\r\n        console.log(\"aRes\");\r\n        console.log(res);\r\n        // TODO: only EUR, no leverage atm, implement some type of switch between quote currencies to draw the different tables\r\n        // or maybe it should be part of it / passed to the table and afterwards be filtered in some data processing func, thats the nicest probably \r\n        // let data = {\r\n        //   tables: aRes.data.tables,\r\n        //   tradesByPair: aRes.data.tradesByPair\r\n        // }\r\n        return res;\r\n    });\r\n}\r\nfunction constructTable(data) {\r\n    var header = {\r\n        'id': 'id',\r\n        'price': 'price',\r\n        'title': 'title',\r\n        'link': 'link',\r\n    };\r\n    let options = {\r\n        // rowFunc: rowFuncInnerTable, // defined below\r\n        sortable: {\r\n            all: true\r\n        },\r\n        alternateColour: false,\r\n        // editable: onEdit // defined below\r\n    };\r\n    let tableHtml = document.getElementById(\"table\");\r\n    // nested table, instantiated for each asset listing the trades of the asset\r\n    let table = new Table(tableHtml, header, data, options);\r\n    // table.options.editable = true\r\n    // table.options.filterBox = true\r\n    table.options.filter = {};\r\n    // table.options.filter.filterConfig = filter_config\r\n    // table.options.filter.filterConfig = TRANSACTION_TYPE\r\n    table.options.search = true;\r\n    table.drawTable();\r\n}\r\n"],"names":[],"sourceRoot":""}